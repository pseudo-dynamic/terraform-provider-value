---
# generated by https://github.com/hashicorp/terraform-plugin-docs
page_title: "value_is_fully_known Resource - terraform-provider-value"
subcategory: ""
description: |-
  Allows you to have a access to result during plan phase that states whether value or any nested attribute is marked as "(known after apply)" or not.
  Provider Metadata
  Each module can use providermeta. Please keep in mind that these settings only count for resources of this module! (see https://www.terraform.io/internals/provider-meta https://www.terraform.io/internals/provider-meta):
  ```terraform
  // Terraform providermeta example
  terraform {
      // "value" is the provider name
      providermeta "value" {
          // {workdir} -> The only available placeholder currently (see below for more information)
          guidseed_addition = "{workdir}#for-example" // Results into "/path/to/workdir#for-example"
      }
  }
  ```
  Optional
  guid_seed_addition (String) It serves as addition to each seed of any value_is_fully_known (resource) or value_is_known (resource) within the project if specified in provider, or within the same module if specified in provider-meta.
  Placeholders:
  "{workdir}" (Keyword) The actual workdir; equals to terraform's path.root. This placeholder is
  recommended because this value won't be dragged along the plan and apply phase in comparison to
  "abspath(path.root)" that you would add to resource seed where a change to path.root would be
  recognized just as usual from terraform.
---

# value_is_fully_known (Resource)

Allows you to have a access to `result` during plan phase that states whether `value` or any nested attribute is marked as "(known after apply)" or not.
## Provider Metadata
Each module can use provider_meta. Please keep in mind that these settings only count for resources of this module! (see [https://www.terraform.io/internals/provider-meta](https://www.terraform.io/internals/provider-meta)):
```terraform
// Terraform provider_meta example
terraform {
	// "value" is the provider name
	provider_meta "value" {
		// {workdir} -> The only available placeholder currently (see below for more information)
		guid_seed_addition = "{workdir}#for-example" // Results into "/path/to/workdir#for-example"
	}
}
```
### Optional
- `guid_seed_addition` (String) It serves as addition to each seed of any `value_is_fully_known` (resource) or `value_is_known` (resource) within the project if specified in provider, or within the same module if specified in provider-meta.

	**Placeholders**:
	- "{workdir}" (Keyword) The actual workdir; equals to terraform's path.root. This placeholder is
	recommended because this value won't be dragged along the plan and apply phase in comparison to
	"abspath(path.root)" that you would add to resource seed where a change to path.root would be
	recognized just as usual from terraform.



<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `guid_seed` (String) Attention! The seed is being used to determine resource uniqueness prior (first plan phase) and during apply phase (second plan phase). Very important to state is that the **seed must be fully known during the plan phase**, otherwise, an error is thrown. Within one terraform plan & apply the **seed of every "value_is_fully_known" must be unique**! I really recommend you to use the provider configuration and/or provider_meta configuration to increase resource uniqueness. Besides `guid_seed`, the provider configuration seed, the provider_meta configuration seed and the resource type itself will become part of the final seed. Under certain circumstances you may face problems if you run terraform concurrenctly. If you do so, then I recommend you to pass-through a random value via a user (environment) variable that you then add to the seed.
- `proposed_unknown` (Dynamic) It is very crucial that this field is **not** filled by any custom value except the one produced by `value_unknown_proposer` (resource). This has the reason as its `value` is **always** unknown during the plan phase. On this behaviour this resource must rely and it cannot check if you do not so!
- `value` (Dynamic) The `value` and if existing, nested attributes, are tested against "(known after apply)"

### Optional

- `result` (Boolean) States whether `value` or any nested attribute is marked as "(known after apply)" or not. If `value` is an aggregate type, not only the top level of the aggregate type is checked; elements and attributes are checked too.


